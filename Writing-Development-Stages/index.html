<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Writing Development Stages — Sequential Pen Animation</title>

  <style>
    /* ===== THEME COLORS ===== */
    :root {
      --board: #0f2f1f;
      --frame: #333;
      --chalk: #fff;
      --bg: #1a1a1a;
      --chalk-glow: rgba(255, 255, 255, 0.35);
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--chalk);
      font-family: 'Comic Sans MS', system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 {
      font-size: 2rem;
      margin: 18px 12px 12px;
      text-shadow: 0 0 8px var(--chalk-glow), 0 0 2px #aaa;
      animation: chalkWrite 3s ease forwards;
      opacity: 0;
    }

    @keyframes chalkWrite {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .wrap {
      width: min(980px, 94vw);
      margin: 0 auto 24px;
    }

    /* ===== BOARD ===== */
    .board {
      background:
        radial-gradient(800px 300px at 10% 10%, rgba(255, 255, 255, .08), transparent 60%),
        radial-gradient(700px 260px at 90% 90%, rgba(255, 255, 255, .06), transparent 60%),
        repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.02) 0px, rgba(255, 255, 255, 0.02) 2px, transparent 2px, transparent 4px),
        var(--board);
      width: 100%;
      aspect-ratio: 16/9;
      border: 8px solid var(--frame);
      border-radius: 16px;
      box-shadow: inset 0 0 45px #000, 0 0 16px #000;
      position: relative;
      overflow: hidden;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .chalk {
      fill: none;
      stroke: var(--chalk);
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      filter: drop-shadow(0 0 2px var(--chalk-glow));
      stroke-dasharray: 2000;
      stroke-dashoffset: 2000;
    }

    /* ===== UI ===== */
    .ui {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 14px;
      justify-content: center;
    }

    button {
      background: #2f2f2f;
      color: var(--chalk);
      border: 2px dashed #888;
      border-radius: 12px;
      padding: 12px 16px;
      cursor: pointer;
      font-weight: 700;
      font-size: 1rem;
      box-shadow: inset 0 0 6px #000, 0 0 6px #000;
      transition: all 0.2s ease;
    }

    button:hover {
      background: #3a3a3a;
      border-color: #fff;
      transform: scale(1.05) rotate(-1deg);
      box-shadow: 0 0 10px var(--chalk-glow);
    }

    .status {
      margin-top: 10px;
      font-size: 1.3rem;
      color: #eee;
      text-align: center;
      animation: pulse 2s infinite alternate;
    }

    @keyframes pulse {
      from {
        opacity: 0.75;
      }

      to {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Writing Development Stages</h1>

    <div class="board">
      <svg id="sv" viewBox="0 0 1200 675" aria-label="blackboard drawing area"></svg>
    </div>

    <div class="ui">
      <button id="btn-random">Random Scribbling</button>
      <button id="btn-controlled">Controlled Scribbling</button>
      <button id="btn-letterlike">Letter-like Forms</button>
      <button id="btn-lettersymbol">Letter / Symbol Relationship</button>
      <button id="btn-invented">Invented Spelling</button>
      <button id="btn-standard">Standard Spelling</button>
    </div>

    <div class="status" id="status">Click a stage to generate a fresh sequential sample.</div>
  </div>

  <!-- Your original JavaScript goes here (unchanged) -->
  <script>
    /* PASTED YOUR ORIGINAL SCRIPT HERE — unchanged to respect the content rule */
    // (keep everything from document.addEventListener ... down to }); 
  </script>
</body>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    /* =========================
       BASIC SVG HELPERS
       ========================= */
    const sv = document.getElementById('sv');

    function clearBoard() { sv.innerHTML = ''; }             // clears all strokes from the board
    function P(tag, attrs = {}) {                            // create any SVG element quickly
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const k in attrs) el.setAttribute(k, attrs[k]);
      return el;
    }
    function L(x1, y1, x2, y2) { return P('line', { x1, y1, x2, y2 }); }   // straight line stroke
    function path(d) { return P('path', { d }); }                          // path stroke (curves)
    function circ(cx, cy, r) { return P('circle', { cx, cy, r }); }        // circle stroke
    function setStatus(msg) { document.getElementById('status').textContent = msg; } // status label

    /* =========================
       DRAW ANIMATION (SEQUENTIAL)
       - drawOne: animates one stroke
       - drawSequential: enforces strict one-by-one order
       Edit 'duration' to speed up/slow down drawing.
       ========================= */
    async function drawOne(el, duration = 700) {
      sv.appendChild(el); // must be in DOM before measuring length
      const L = (typeof el.getTotalLength === 'function') ? el.getTotalLength() : 1000;
      el.classList.add('chalk');            // apply stroke style
      el.style.strokeDasharray = L;
      el.style.strokeDashoffset = L;
      try {
        await el.animate(
          [{ strokeDashoffset: L }, { strokeDashoffset: 0 }],
          { duration, easing: 'linear', fill: 'forwards' }
        ).finished;
      } catch (e) {
        // No-op if interrupted (e.g., user clicks a new button mid-animation)
      }
    }
    async function drawSequential(strokes, dur = 700) {
      for (const s of strokes) { await drawOne(s, dur); }
    }

    /* =========================
       RANDOM UTILITIES
       - rand / randint for random numbers
       - J(j) adds +/- jitter (imperfections)
       Tweak ranges inside stages to change "messiness"
       ========================= */
    const rand = (a, b) => Math.random() * (b - a) + a;
    const randint = (a, b) => Math.floor(rand(a, b + 1));
    function J(j) { return (Math.random() * 2 - 1) * j; } // jitter

    /* =========================
       GLYPH "STROKE FONT" (UPPERCASE SUBSET)
       - Add new letters by following the function signature (x, y, size, jitter)
       - Each letter returns an array of strokes (line/path/circle elements)
       - For size: 1 means base height ~100px; increase for bigger letters
       - For jitter: small 'J(j)' calls add child-like wobble
       ========================= */
    const glyphs = {
      // EXAMPLE: 'A' built from 3 lines
      'A': (x, y, s, j = 0) => [
        L(x, y, x + 25 * s + J(j), y - 100 * s + J(j)),
        L(x + 50 * s, y, x + 25 * s + J(j), y - 100 * s + J(j)),
        L(x + 12 * s, y - 55 * s, x + 38 * s, y - 55 * s)
      ],
      'C': (x, y, s, j = 0) => [
        path(`M ${x + 50 * s} ${y - 10 * s}
                Q ${x + 5 * s + J(j)} ${y - 10 * s + J(j)} ${x + 5 * s} ${y - 55 * s}
                Q ${x + 5 * s + J(j)} ${y - 100 * s + J(j)} ${x + 50 * s} ${y - 100 * s}`)
      ],
      'D': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        path(`M ${x} ${y - 100 * s}
                Q ${x + 55 * s + J(j)} ${y - 80 * s + J(j)} ${x + 55 * s} ${y - 50 * s}
                Q ${x + 55 * s + J(j)} ${y - 20 * s + J(j)} ${x} ${y}`)
      ],
      'E': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x, y),
        L(x, y - 100 * s, x + 48 * s, y - 100 * s),
        L(x, y - 52 * s, x + 38 * s, y - 52 * s),
        L(x, y, x + 48 * s, y)
      ],
      'H': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        L(x + 50 * s, y, x + 50 * s, y - 100 * s),
        L(x, y - 55 * s, x + 50 * s, y - 55 * s)
      ],
      'I': (x, y, s, j = 0) => [L(x + 25 * s, y, x + 25 * s, y - 100 * s)],
      'J': (x, y, s, j = 0) => [
        L(x + 35 * s, y - 100 * s, x + 35 * s, y - 20 * s),
        path(`M ${x + 35 * s} ${y - 20 * s} Q ${x + 35 * s} ${y} ${x + 10 * s} ${y}`)
      ],
      'K': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x, y),
        L(x, y - 55 * s, x + 50 * s, y - 100 * s),
        L(x, y - 55 * s, x + 50 * s, y)
      ],
      'L': (x, y, s, j = 0) => [L(x, y - 100 * s, x, y), L(x, y, x + 48 * s, y)],
      'M': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        L(x, y - 100 * s, x + 25 * s, y - 60 * s),
        L(x + 25 * s, y - 60 * s, x + 50 * s, y - 100 * s),
        L(x + 50 * s, y - 100 * s, x + 50 * s, y)
      ],
      'N': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        L(x, y - 100 * s, x + 50 * s, y),
        L(x + 50 * s, y, x + 50 * s, y - 100 * s)
      ],
      'O': (x, y, s, j = 0) => [circ(x + 28 * s + J(j), y - 50 * s + J(j), 28 * s)],
      'P': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        path(`M ${x} ${y - 100 * s}
                Q ${x + 48 * s + J(j)} ${y - 95 * s + J(j)} ${x + 48 * s} ${y - 75 * s}
                Q ${x + 48 * s + J(j)} ${y - 55 * s + J(j)} ${x} ${y - 55 * s}`)
      ],
      'R': (x, y, s, j = 0) => [
        L(x, y, x, y - 100 * s),
        path(`M ${x} ${y - 100 * s}
                Q ${x + 48 * s + J(j)} ${y - 95 * s + J(j)} ${x + 48 * s} ${y - 75 * s}
                Q ${x + 48 * s + J(j)} ${y - 55 * s + J(j)} ${x} ${y - 55 * s}`),
        L(x, y - 55 * s, x + 50 * s, y)
      ],
      'S': (x, y, s, j = 0) => [
        path(`M ${x + 48 * s} ${y - 92 * s}
                Q ${x + 5 * s + J(j)} ${y - 92 * s + J(j)} ${x + 5 * s} ${y - 72 * s}
                Q ${x + 5 * s + J(j)} ${y - 55 * s + J(j)} ${x + 48 * s} ${y - 55 * s}
                Q ${x + 48 * s + J(j)} ${y - 20 * s + J(j)} ${x + 5 * s} ${y - 20 * s}`)
      ],
      'T': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x + 50 * s, y - 100 * s),
        L(x + 25 * s, y - 100 * s, x + 25 * s, y)
      ],
      'U': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x, y - 20 * s),
        path(`M ${x} ${y - 20 * s} Q ${x + 25 * s} ${y + 10 * s} ${x + 50 * s} ${y - 20 * s}`),
        L(x + 50 * s, y - 20 * s, x + 50 * s, y - 100 * s)
      ],
      'V': (x, y, s, j = 0) => [L(x, y - 100 * s, x + 25 * s, y), L(x + 25 * s, y, x + 50 * s, y - 100 * s)],
      'W': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x + 12 * s, y),
        L(x + 12 * s, y, x + 25 * s, y - 60 * s),
        L(x + 25 * s, y - 60 * s, x + 38 * s, y),
        L(x + 38 * s, y, x + 50 * s, y - 100 * s)
      ],
      'Y': (x, y, s, j = 0) => [
        L(x, y - 100 * s, x + 25 * s, y - 55 * s),
        L(x + 50 * s, y - 100 * s, x + 25 * s, y - 55 * s),
        L(x + 25 * s, y - 55 * s, x + 25 * s, y)
      ],
      ' ': (x, y, s) => [],                                // space (no strokes)
      '.': (x, y, s) => [circ(x + 10 * s, y - 5 * s, 3.5 * s)] // small dot
    };
    const ALLOWED = "AEHIKLMNORSTUWY"; // letters used to compose random "invented" words

    /* Draw a word letter-by-letter, stroke-by-stroke (sequence guaranteed)
       - str: text
       - x, y: baseline start
       - size: scale factor (1 = ~100px high)
       - jitter: child-like wobble
       - letterGap: extra spacing between letters
       - durPer: ms per stroke (speed of each line)
       TIP: To speed all writing, lower 'durPer'. To enlarge, increase 'size'.
    */
    async function drawWord(str, x, y, size = 1, jitter = 0, letterGap = 22 * size, durPer = 600) {
      let cursor = x;
      for (const ch of str) {
        const up = ch.toUpperCase();
        const g = glyphs[up];
        if (!g) { cursor += 40 * size; continue; } // skip unsupported characters
        const strokes = g(cursor, y, size, jitter);
        for (const s of strokes) { await drawOne(s, durPer); }
        cursor += 60 * size + letterGap; // advance pen to next letter start
      }
    }

    /* =========================
       STAGES
       - Each stage clears the board, sets a status message,
         and draws strokes SEQUENTIALLY.
       - Tweak the numeric ranges inside each stage to change density/shape.
       ========================= */

    /* ---- 1) Random Scribbling ----
       Messy curves with random directions and curved segments.
       Increase 'count' for more scribbles; adjust segment ranges for density. */
    async function stageRandomScribbling() {
      clearBoard();
      setStatus("Random Scribbling — making marks on paper randomly with little hand control…");

      const count = randint(8, 14); // number of independent scribbles
      for (let i = 0; i < count; i++) {
        const startX = rand(60, 1140), startY = rand(60, 615);
        let d = `M ${startX} ${startY}`;
        const segments = randint(3, 6); // how many curves per scribble

        let prevAngle = null;
        let px = startX, py = startY;
        for (let s = 0; s < segments; s++) {
          // pick a new direction, avoid tiny angle changes to prevent parallel monotony
          let ang, tries = 0;
          do {
            ang = rand(0, Math.PI * 2);
            tries++;
          } while (
            prevAngle !== null &&
            Math.abs(Math.atan2(Math.sin(ang - prevAngle), Math.cos(ang - prevAngle))) < (Math.PI / 7) &&
            tries < 10
          );
          prevAngle = ang;

          // control point and end point (quadratic curve)
          const len = rand(60, 180);
          const cx = px + Math.cos(ang) * len * rand(0.4, 0.7);
          const cy = py + Math.sin(ang) * len * rand(0.4, 0.7);
          const ex = px + Math.cos(ang) * len;
          const ey = py + Math.sin(ang) * len;
          d += ` Q ${cx} ${cy} ${ex} ${ey}`;
          px = ex; py = ey;
        }
        await drawOne(path(d), randint(550, 950)); // per-scribble duration
      }
      setStatus("Random Scribbling — making marks on paper randomly with little hand control…");
    }

    /* ---- 2) Controlled Scribbling ----
       Straight lines, ladders, small boxes—more repetition & motor control.
       Edit the 'mode' array to bias which pattern appears. */
    async function stageControlledScribbling() {
      clearBoard();
      setStatus("Controlled Scribbling — straight lines and repeated patterns…");

      const mode = ['hLines', 'vLadders', 'boxes'][randint(0, 2)];

      if (mode === 'hLines') {
        const rows = randint(4, 7);            // how many horizontal lines
        const top = rand(120, 500), gap = rand(25, 55);
        for (let r = 0; r < rows; r++) {
          const y = top + r * gap;
          await drawOne(L(80, y, 1120, y), 650);
        }

      } else if (mode === 'vLadders') {
        const cols = randint(4, 7);            // how many vertical rails
        const left = rand(150, 950), gap = rand(45, 80);
        for (let c = 0; c < cols; c++) {
          const x = left + c * gap;
          await drawOne(L(x, 120, x, 560), 700);
        }
        // ladder steps
        for (let y = 150; y <= 540; y += randint(55, 85)) {
          await drawOne(L(left - 20, y, left + gap * (cols - 1) + 20, y), 550);
        }

      } else { // boxes grid
        const rows = randint(2, 3), cols = randint(4, 6), w = 70, h = 50;
        const startX = rand(120, 1200 - (cols * (w + 30)));
        const startY = rand(140, 560 - (rows * (h + 30)));
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = startX + c * (w + 30), y = startY + r * (h + 30);
            await drawOne(L(x, y, x + w, y), 420);
            await drawOne(L(x + w, y, x + w, y + h), 420);
            await drawOne(L(x + w, y + h, x, y + h), 420);
            await drawOne(L(x, y + h, x, y), 420);
          }
        }
      }
      setStatus("Controlled Scribbling — drawing or writing in straight lines across the paper. Repeated patterns show better hand control.");
    }

    /* ---- 3) Letter-like Forms (mock handwriting) ----
       Mixture of abstract "pretend writing" shapes + distorted letter-like symbols.
       Children’s mock writing often alternates between scribbles and
       something that loosely resembles letters.
    */

    /* === LESS-LIKE LETTERS (abstract scribbles / shapes) === */
    function pseudoZigzag(x, y, s) {
      return [
        L(x, y - 20 * s, x + 20 * s, y - 60 * s + J(10)),
        L(x + 20 * s, y - 60 * s, x, y - 100 * s + J(10)),
        L(x, y - 100 * s, x + 40 * s, y - 20 * s + J(10))
      ];
    }
    function pseudoLoop(x, y, s) {
      const d = `M ${x} ${y - 60 * s}
             Q ${x + 30 * s} ${y - 120 * s} ${x + 60 * s} ${y - 60 * s}
             Q ${x + 30 * s} ${y} ${x} ${y - 60 * s}`;
      return [path(d)];
    }
    function pseudoBrokenCircle(x, y, s) {
      const d = `M ${x + 20 * s} ${y - 100 * s}
             Q ${x - 10 * s} ${y - 60 * s + J(10)} ${x + 20 * s} ${y - 20 * s}
             Q ${x + 50 * s} ${y + J(10)} ${x + 60 * s} ${y - 40 * s}`;
      return [path(d)];
    }
    function pseudoSpikes(x, y, s) {
      return [
        L(x, y, x, y - 40 * s + J(10)),
        L(x + 20 * s, y, x + 20 * s, y - 70 * s + J(10)),
        L(x + 40 * s, y, x + 40 * s, y - 50 * s + J(10))
      ];
    }
    function pseudoSnake(x, y, s) {
      const d = `M ${x} ${y - 100 * s}
             Q ${x + 40 * s} ${y - 80 * s} ${x} ${y - 60 * s}
             Q ${x - 40 * s} ${y - 40 * s} ${x + 10 * s} ${y - 20 * s}
             Q ${x + 50 * s} ${y} ${x + 20 * s} ${y - 10 * s}`;
      return [path(d)];
    }
    function pseudoTriangle(x, y, s) {
      return [
        L(x, y, x + 30 * s, y - 80 * s + J(8)),
        L(x + 30 * s, y - 80 * s, x + 60 * s, y + J(8)),
        L(x + 60 * s, y, x, y)
      ];
    }
    function pseudoWavyLine(x, y, s) {
      const d = `M ${x} ${y - 40 * s}
             Q ${x + 20 * s} ${y - 60 * s} ${x + 40 * s} ${y - 40 * s}
             Q ${x + 60 * s} ${y - 20 * s} ${x + 80 * s} ${y - 40 * s}`;
      return [path(d)];
    }
    function pseudoDotDash(x, y, s) {
      return [
        circ(x + 10 * s, y - 10 * s, 5 * s),
        L(x + 25 * s, y - 20 * s, x + 55 * s, y - 20 * s + J(5))
      ];
    }

    /* === MORE-LETTER-LIKE (distorted letters) === */
    function pseudoAlike(x, y, s) {
      return [
        L(x, y, x + 20 * s + J(6), y - 100 * s + J(6)),
        L(x + 55 * s, y, x + 20 * s + J(6), y - 100 * s + J(6)),
        L(x + 5 * s, y - 70 * s, x + 40 * s, y - 50 * s)
      ];
    }
    function pseudoHlike(x, y, s) {
      return [
        L(x, y, x, y - 80 * s + J(6)),
        L(x + 50 * s, y, x + 50 * s, y - 100 * s),
        L(x, y - 40 * s, x + 50 * s, y - 60 * s + J(6))
      ];
    }
    function pseudoNlike(x, y, s) {
      return [
        L(x, y, x, y - 100 * s),
        path(`M ${x} ${y - 100 * s} Q ${x + 40 * s} ${y - 30 * s} ${x + 60 * s} ${y + J(6)}`),
        L(x + 55 * s, y, x + 55 * s, y - 100 * s + J(6))
      ];
    }
    function pseudoOlike(x, y, s) {
      const d = `M ${x + 20 * s} ${y - 95 * s}
             Q ${x - 10 * s} ${y - 60 * s} ${x + 15 * s} ${y - 25 * s}
             Q ${x + 40 * s} ${y} ${x + 55 * s} ${y - 40 * s}
             Q ${x + 60 * s} ${y - 80 * s} ${x + 25 * s} ${y - 100 * s}`;
      return [path(d)];
    }
    function pseudoMlike(x, y, s) {
      return [
        L(x, y, x, y - 90 * s),
        L(x, y - 90 * s, x + 20 * s, y - 40 * s + J(6)),
        L(x + 20 * s, y - 40 * s, x + 45 * s, y - 100 * s),
        L(x + 45 * s, y - 100 * s, x + 50 * s, y - 50 * s)
      ];
    }
    function pseudoSlike(x, y, s) {
      const d = `M ${x + 40 * s} ${y - 95 * s}
             Q ${x} ${y - 95 * s} ${x + 15 * s} ${y - 60 * s}
             Q ${x + 35 * s} ${y - 40 * s} ${x + 50 * s} ${y - 30 * s}
             Q ${x + 70 * s} ${y - 10 * s} ${x + 20 * s} ${y}`;
      return [path(d)];
    }

    /* === Pool mixes both abstract + letter-like === */
    const PSEUDO_FACTORIES = [
      pseudoZigzag, pseudoLoop, pseudoBrokenCircle, pseudoSpikes,
      pseudoSnake, pseudoTriangle, pseudoWavyLine, pseudoDotDash,
      pseudoAlike, pseudoHlike, pseudoNlike, pseudoOlike,
      pseudoMlike, pseudoSlike
    ];

    async function stageLetterLike() {
      clearBoard();
      setStatus("Letter-like Forms — shapes that resemble writing, some closer to letters, others just scribbles…");
      const count = randint(3, 7);
      let x = rand(120, 220), y = rand(300, 520);
      let size = rand(1.0, 1.3);
      for (let i = 0; i < count; i++) {
        const f = PSEUDO_FACTORIES[randint(0, PSEUDO_FACTORIES.length - 1)];
        const strokes = f(x, y, size);
        for (const s of strokes) { await drawOne(s, 520); }
        x += rand(90, 140);
        if (x > 1000) { x = rand(120, 220); y += rand(-40, 40); }
      }
      setStatus("Letter-like Forms — completed.");
    }


    /* ---- 4) Letter/Symbol Relationship ----
       Real letters appear; often draw a name with wobbly strokes.
       Edit NAMES array to change the pool. */
    const NAMES = ["HENRY", "JULIA", "ANA", "LIAM", "MIA", "LILY", "NINA", "IVY", "HANA", "TINA", "RYAN", "EMI", "WILL"];
    async function stageLetterSymbol() {
      clearBoard();
      const name = NAMES[randint(0, NAMES.length - 1)];
      setStatus(`Letter/Symbol — writing their own name (“${name}”) with more realistic letters…`);
      await drawWord(name, 90, 420, 1.35, 3.5, 14, 640); // x,y,size,jitter,letterGap,duration
      setStatus(`Letter/Symbol — finished name “${name}”.`);
    }

    /* ---- 5) Invented Spelling ----
       Random letter strings (sometimes a real name mixed in), optional punctuation.
       - ALLOWED controls which letters may appear.
       - Adjust wrap width (maxChars) and line spacing for layout. */
    function randWord(len) { let s = ""; for (let i = 0; i < len; i++) { s += ALLOWED[randint(0, ALLOWED.length - 1)]; } return s; }
    function maybePunct() { return Math.random() < 0.4 ? ["!", ".", "?"][randint(0, 2)] : ""; }

    // Simple word-wrap by character count (not pixel width)
    function wrapIntoLines(text, maxChars) {
      const words = text.split(/\s+/);
      const lines = [];
      let cur = "";
      for (const w of words) {
        const candidate = cur ? cur + " " + w : w;
        if (candidate.length <= maxChars) {
          cur = candidate;
        } else {
          if (cur) lines.push(cur);
          cur = w;
        }
      }
      if (cur) lines.push(cur);
      return lines;
    }

    async function stageInvented() {
      clearBoard();
      setStatus("Invented Spelling — pretend words that are not actual words…");

      // Build 3–5 words; occasionally swap one for a real name
      const words = Array.from({ length: randint(3, 5) }, _ => randWord(randint(2, 6)));
      if (Math.random() < 0.5) { const i = randint(0, words.length - 1); words[i] = NAMES[randint(0, NAMES.length - 1)]; }

      const text = words.join(" ") + maybePunct();
      const lines = wrapIntoLines(text, 14); // maxChars per line for wrapping

      const startX = 80, firstY = 260, lineGap = 120; // layout controls
      for (let i = 0; i < lines.length; i++) {
        await drawWord(lines[i], startX, firstY + i * lineGap, 1.15, 2.5, 14, 520);
      }
      setStatus("Invented Spelling — complete.");
    }

    /* ---- 6) Standard / Conventional Spelling ----
       Short, correct sentences.
       - Edit SENTENCES to control content. */
    const SENTENCES = ["I CAN RUN.", "PUPPY IS HERE.", "WE CAN RUN.", "MOM LOVE ME", "I CAN WIN."];

    async function stageStandard() {
      clearBoard();
      const s = SENTENCES[randint(0, SENTENCES.length - 1)];
      setStatus(`Standard Spelling — conventional phonetic spelling: “${s}”`);
      await drawWord(s, 120, 360, 1.3, 1.2, 18, 600);
      setStatus("Standard Spelling — complete.");
    }

    /* =========================
       EVENT WIRING (buttons)
       - If you add a new stage, create a button and add a handler here.
       ========================= */
    document.getElementById('btn-random').addEventListener('click', stageRandomScribbling);
    document.getElementById('btn-controlled').addEventListener('click', stageControlledScribbling);
    document.getElementById('btn-letterlike').addEventListener('click', stageLetterLike);
    document.getElementById('btn-lettersymbol').addEventListener('click', stageLetterSymbol);
    document.getElementById('btn-invented').addEventListener('click', stageInvented);
    document.getElementById('btn-standard').addEventListener('click', stageStandard);

    /* Initial helper text */
    setStatus("Click any stage. Each stroke is drawn one-by-one like a pen.");
  }); // DOMContentLoaded
</script>
</body>

</html>
